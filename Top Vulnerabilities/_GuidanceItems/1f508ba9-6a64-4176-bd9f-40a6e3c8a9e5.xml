<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-727543895" Content_Hash="1251207828">
  <Metadata>
    <Id>1f508ba9-6a64-4176-bd9f-40a6e3c8a9e5</Id>
    <Id_History>1163e128-6417-4051-8f8c-36e695f8aded,</Id_History>
    <Library_Id>26bd1a04-beed-4a66-917d-b6ab0a7d634c</Library_Id>
    <Title>How to Test for XML Injection Vulnerabilities</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Test</Phase>
    <Technology> Any</Technology>
    <Type>How To</Type>
    <DirectLink>How to Test for XML Injection Vulnerabilities</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>
    <span>Applies To</span>
  </h1>
  <ul>
    <li>
      <span>Web services that use XML</span>
    </li>
    <li>
      <span>Web services that use SOAP</span>&amp;nbsp;</li>
  </ul>
  <h1>
    <span>Summary</span>
  </h1>
  <p>
    <span>XML stands for Extensible Markup Language.<span>&amp;nbsp;</span>Similar to HTML, it utilizes tags to store structured data.<span>&amp;nbsp;</span>However, XML is extensible as it allows users to define their own elements in user defined tags.</span>
  </p>
  <p>
    <span>In web software, the two most noticeable uses for XML are: </span>
  </p>
  <ol>
    <li>
      <span>Store structured data as an alternative to a database. </span>
    </li>
    <li>
      <span>Provide a transaction protocol for business-to-business and business-to-client communications such as SOAP.</span>
    </li>
  </ol>
  <h2>
    <span>
      Store structured data as an alternative to a database
    </span>
  </h2>
  <p>
    <span>A server stores user names, passwords, and emails in the user element.<span>&amp;nbsp; </span>It uses a web form to collect user data.&amp;nbsp;</span>A user enters the following data and clicks on the Create User button:</p>
  <p>
    <font face="'Courier New'">Username: JohnyC<br />Password: qwerty<br />E-mail: johnyc@examplesite.com</font>
  </p>
  <p>The client sends this URL to the server application:</p>
  <p>
    <font face="'Courier New'">http://www.examplesite.com/GetProfile.php?username=JohnyC&amp;password=qwerty &amp;email=JohnyC@examplesite.com</font>
  </p>
  <p>Once the server receives the URL it creates a user&amp;nbsp;XML&amp;nbsp;element&amp;nbsp;node:
    
      &amp;nbsp;</p>
  <p>
    <font face="'Courier New'">&lt;user&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;&lt;username&gt;JohnyC&lt;/username&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;&lt;password&gt;qwerty&lt;/password&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;&lt;userid&gt;111&lt;userid/&gt;<br />&amp;nbsp; &amp;nbsp;&lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;<br />&lt;/user&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;</font>
  </p>
  <h2>
    <span>
      Provide a transaction protocol for business-to-business and business-to-client communications (such as SOAP)
    </span>
  </h2>
  <p>
    <span>The second and most used XML benefit is to integrate web services.<span>&amp;nbsp; </span>SOAP is the communication protocol for XML web services.&amp;nbsp;Before XML, systems had to implement Remote Procedure Calls (RPC) to integrate cross platform services on the web.<span>&amp;nbsp;</span>At that time COBRA or DCE were mostly used to achieve integration, but they were too complex.<span>&amp;nbsp;</span>SOAP defined a standard XML communication protocol that was adopted because of its simplicity.<span>&amp;nbsp;</span>As Microsoft released SOAP, they also released a toolkit that translated COM to SOAP, as well as one to translate Java Functions to SOAP.</span>
  </p>
  <p>
    <span>The following code shows an XML-based SOAP client that invokes the </span>
    <span>sayHello </span>
    <span>method on a SOAP server:</span>
  </p>
  <p>
    <font face="'Courier New'">Dim x, h<br />Set x = CreateObject("MSXML2.DOMDocument")<br />x.loadXML "&lt;s:Envelope xmlns:s='http://schemas.xmlsoap.org/soap/envelope/'&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;xmlns:xsi='http://www.w3.org/1999/XMLSchema-instance'&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;xmlns:xsd='http://www.w3.org/1999/XMLSchema'&gt;&lt;s:Body&gt;&lt;m:sayHello&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;xmlns:m='urn:Example1'&gt;&lt;name xsi:type='xsd:string'&gt;James&lt;/name&gt;&lt;<br />&amp;nbsp; &amp;nbsp;/m:sayHello&gt;&lt;/s:Body&gt;&lt;/s:Envelope&gt;"<br />msgbox x.xml, , "Input SOAP Message"<br />Set h = CreateObject("Microsoft.XMLHTTP")<br />h.open "POST", "http://localhost:8080"<br />h.send (x)<br />while h.readyState &lt;&gt; 4<br />wend<br />msgbox h.responseText,,"Output SOAP Message"</font>
  </p>
  <h2>
    <span>
      XML Injection Bugs
    </span>
  </h2>
  <p>
    <span>XML injection means to maliciously feed crafted data to a XML-based web service in order to execute an attack.<span>&amp;nbsp;</span>An XML injection attack varies from adding extra elements in an XML store to tamper with sensitive information to modifying XML store tags to execute cross-site scripting code in a target browser.</span>
  </p>
  <p>
    <span>The following steps are needed to test for XML Injection:</span>
  </p>
  <ol>
    <li>
      <span>Understand XML Injection attack scenarios.</span>
    </li>
    <li>
      <span>Identify high risk components.</span>
    </li>
    <li>
      <span>Start testing and exploring.</span>
    </li>
    <li>
      <span>Tune test cases.</span>
    </li>
  </ol>
  <p>
    <span>It is necessary to differentiate XML injection with XPATH or XQUERY bugs.&amp;nbsp;They are similar as they both relate to XML, but the logic involved is fundamentally different and will be discussed in individual articles.</span>&amp;nbsp;</p>
  <h1>
    <span>Step 1:<span>&amp;nbsp;</span>Understand XML Injection attack scenarios</span>
  </h1>
  <p>
    <span>During the first step, you need to understand how an XML injection attack works both in storage and communication.<span>&amp;nbsp;</span>The following two scenarios elaborate on XML injection attacks:</span>
  </p>
  <ul>
    <li>
      <span>Injecting an extra tag to a XML data store.</span>
    </li>
    <li>
      <span>Executing cross-site scripting attacks by manipulating the CDATA tag.</span>&amp;nbsp;</li>
  </ul>
  <h2>
    <span>
      Scenario 1:<span>&amp;nbsp;</span>Injecting an extra tag to a XML data store
    </span>
  </h2>
  <p>
    <span>A bank site exposes a simple web page to create checking accounts. <span>&amp;nbsp;</span>It takes data from a web form like the one above and builds a URL like this one:</span>
  </p>
  <p>
    <font face="'Courier New'">http://www.examplesite.com/CreateChecking.php?username=JohnyC&amp;password=qwerty&amp;email=JohnyC@examplesite.com</font>
  </p>
  <p>
    <span>The bank uses the data in the URL to construct the following XML in its data store:</span>
  </p>
  <p>
    <font face="'Courier New'">&lt;user&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;&lt;username&gt;JohnyC&lt;/username&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;&lt;password&gt;qwerty&lt;/password&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;&lt;userid&gt;111&lt;userid/&gt;<br />&amp;nbsp; &amp;nbsp;&lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;<br />&amp;nbsp; &amp;nbsp;&lt;account type=”checking”&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;created&gt;02-21-2008&lt;/created&gt;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;number&gt;1249109&lt;/number&gt;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;balance&gt;1201&lt;/balance&gt;<br />&amp;nbsp; &amp;nbsp;&lt;/account&gt;&amp;nbsp;<br />&lt;/user&gt;</font>
  </p>
  <p>
    <span>The bank doesn’t provide a web interface to create saving accounts.<span>&amp;nbsp;</span>In order to open a saving account, clients need to go to the bank and provide additional information.&amp;nbsp;The bank exposes a security vulnerability that allows the attacker to feed malicious data in the web form.<span>&amp;nbsp;</span>The attacker submits the following URL request:</span>
  </p>
  <p>
    <font face="'Courier New'">http://www.examplesite.com/CreateChecking.php?username=JohnyC&amp;password=qwerty&amp;email=JohnyC@examplesite.com&lt;/mail&gt;&lt;account type="savings"&gt;&lt;created&gt;03-02-2008&lt;/created&gt;&lt;number&gt;12345678&lt;/number&gt;&lt;balance&gt;1000000&lt;/balance&gt;&lt;/account&gt;</font>
  </p>
  <p>When the bank receives this request it&amp;nbsp;doesn't&amp;nbsp;check for extra tags and builds the following element in its data store:</p>
  <p>
    <font face="'Courier New'">&lt;user&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;&lt;username&gt;JohnyC&lt;/username&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;&lt;password&gt;qwerty&lt;/password&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;&lt;userid&gt;111&lt;userid/&gt;<br />&amp;nbsp; &amp;nbsp;&lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;<br />&amp;nbsp; &amp;nbsp;&lt;account type="savings"&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;created&gt;03-02-2008&lt;/created&gt;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;number&gt;12345678&lt;/number&gt;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;balance&gt;1000000&lt;/balance&gt;<br />&amp;nbsp; &amp;nbsp;&lt;/account&gt;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;account type=”checking”&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;created&gt;02-21-2008&lt;/created&gt;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;number&gt;1249109&lt;/number&gt;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;balance&gt;1201&lt;/balance&gt;<br />&amp;nbsp; &amp;nbsp;&lt;/account&gt; &amp;nbsp;<br />&lt;/user&gt;</font>
  </p>
  <p>The bug in the bank web application here allows the attacker to remotely create a savings account with a $1000000 balance.&amp;nbsp;</p>
  <h2>
    <span>
      Scenario 2:<span>&amp;nbsp; </span>Executing cross-site scripting attacks by manipulating the CDATA tag 
    </span>
  </h2>
  <p>
    XML uses the <i>CDATA </i>tag to escape blocks of text that would be otherwise recognized as markup.<span>&amp;nbsp;</span>All data enclosed in between the tags <i>&lt;![CDATA[</i>&amp;nbsp;and <i>]]&gt;</i>&amp;nbsp;
    
    will not be parsed as markup.<span>&amp;nbsp; </span></p>
  <p>
    A vulnerable server uses a file named <i>scenarios.xml</i> to store the title and the data for each scenario:</p>
  <p>
    <font face="'Courier New'">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;<br />&lt;scenarios&gt;<br />&amp;nbsp; &amp;nbsp;&lt;scenario&gt;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;title&gt;XSS scenario&lt;/title&gt;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;data&gt;&lt;![CDATA[this is not to be parsed &lt;!-- as XML '"&gt;&lt;]]&gt;&lt;/data&gt;<br />&amp;nbsp; &amp;nbsp;&lt;/scenario&gt;<br />&amp;nbsp; &amp;nbsp;etc…<br />&lt;/scenarios&gt;</font>
  </p>
  <p>
    The application blindly builds a page (<i>scenarios.php</i>) from the XML file using the following code and then sends the page back to the client:</p>
  <p>
    <font face="'Courier New'">&lt;?php&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;$objDOM = new DOMDocument();&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;$objDOM-&gt;load("scenarios.xml");&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;$scenario = $objDOM-&gt;getElementsByTagName("scenario");<br />&amp;nbsp; &amp;nbsp;foreach( $scenario as $value )<br />&amp;nbsp; &amp;nbsp;{<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;$title&amp;nbsp; = $value-&gt;getElementsByTagName("title")-&gt;item(0)-&gt;nodeValue;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;$data =&amp;nbsp;&amp;nbsp; $value-&gt;getElementsByTagName("data")-&gt;item(0)-&gt;nodeValue;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;echo "$title:&lt;br&gt;$data&lt;br&gt;";<br />&amp;nbsp; &amp;nbsp;}<br />?&gt;</font>
  </p>
  <p>
    <span>The scenario above will generate the following output:</span>
  </p>
  <p>
    <font face="'Courier New'">XSS scenario<br />this is not be parsed as XML '"&gt;&lt;</font>
  </p>
  <p>Now the attacker gets control of <i>scenarios.xml </i>and modifies the data tag to look like this:</p>
  <p>
    <font face="'Courier New'">&lt;scenario&gt;<br />&amp;nbsp; &amp;nbsp;&lt;title&gt;XSS scenario&lt;/title&gt;<br />&amp;nbsp; &amp;nbsp;&lt;data&gt;&lt;![CDATA[&lt;script&gt;alert('XSS')&lt;/script&gt;]]&gt;&lt;/data&gt;<br />&lt;/scenario&gt;&amp;nbsp;</font>
  </p>
  <p>
    <span>This will result in the vulnerable application building a page that executes attacker specified JavaScript and sending it to the client.&amp;nbsp;</span>That results in a cross-site scripting attack because the server&amp;nbsp;doesn't&amp;nbsp;validate the XML output before sending it back as HTML to the client.&amp;nbsp;</p>
  <h1>
    <span>Step 2:<span>&amp;nbsp;</span>Identify high risk components</span>
  </h1>
  <p>
    <span>The next steps for XML Injection testing are to list all of the places where code builds XML statements from user supplied input; and to understand how and where our application manipulates statements, and how it uses them to modify its data store or to invoke XML web methods.<span>&amp;nbsp;</span>The most common are:</span>
  </p>
  <ul>
    <li>
      <span>Profile-related web pages.</span>
    </li>
    <li>
      <span>E-Commerce or financial account-related pages.</span>
    </li>
    <li>
      <span>XML web service interaction methods.</span>
    </li>
    <li>
      <span>XML-based system-level clients.</span>
    </li>
    <li>
      <span>Systems that read from XML&amp;nbsp;back-end&amp;nbsp;and blindly construct responses to Internet clients.</span>&amp;nbsp;</li>
  </ul>
  <h2>
    <span>
      Identify all high risk components 
    </span>
  </h2>
  <p>
    <span>This subtask consists of indentifying the coding errors that lead to XML injection bugs.<span>&amp;nbsp;</span>XML injection bugs exist for two main reasons.<span>&amp;nbsp;</span>First, when a server-side application directly utilizes user-supplied strings that arrive over the Internet to add into their XML data store or perform other XML-related tasks.<span>&amp;nbsp;</span>The application doesn’t do any sort of data validation on the strings, and therefore allows for injection of XML tags.<span>&amp;nbsp;</span>In the second case, an application is vulnerable if it reads from an XML store and blindly constructs an HTML page to send back to the client.</span>
  </p>
  <p>
    <span>During this subtask, you need to go through all web pages in the application under test and look for any XML interaction.<span>&amp;nbsp;</span>Any page or method that uses XML to transmit data must be listed as a high risk component.<span>&amp;nbsp;</span>Following are some common examples of what you need to look for when reviewing code for XML injection bugs.</span>
  </p>
  <h2>
    <span>
      Identify the usage of XML parsers
    </span>
  </h2>
  <p>
    <span>Server-side applications can choose from a wide variety of XML parsers depending on the language they are written.<span>&amp;nbsp;</span>It is important that you recognize if the application you’re testing uses any of these parsers.&amp;nbsp;If so, it is a clear indication that the application manipulates XML.<span>&amp;nbsp; </span></span>
  </p>
  <ul>
    <li>
      <i>
        <span>SAXParser (Java)</span>
      </i>
    </li>
    <li>
      <i>
        <span>MSXML (including Microsoft XML DOM Parser)</span>
      </i>
    </li>
    <li>
      <i>
        <span>Xerces (Java, C++, Perl)</span>
      </i>
    </li>
    <li>
      <i>
        <span>Oracle XML Parser</span>
      </i>
    </li>
    <li>
      <i>
        <span>XML Booster</span>
      </i>
    </li>
    <li>
      <i>
        <span>XML::Parser (form Perl)</span>
      </i>
    </li>
    <li>
      <span>
        <i>XParse</i>
      </span>
    </li>
  </ul>
  <p>
    <span>This short list illustrates that the programmer has different choices when selecting an XML parser.<span>&amp;nbsp;</span>Make sure to look for the presence of any of these.<span>&amp;nbsp;</span>In addition, keep up with the latest XML parsing technology and research for additional parsers that your application might use.</span>
  </p>
  <h2>
    <span>
      Look for code that writes XML from user-supplied input
    </span>
  </h2>
  <p>
    <span>Any code that uses user-supplied input (from web forms, URLs, etc) must be marked as high risk.<span>&amp;nbsp;</span>Below is an example that uses the input parameter from a URL to construct XML:</span>
  </p>
  <p>
    <font face="'Courier New'">set xmlDoc=CreateObject("Microsoft.XMLDOM")<br />xmlDoc.async="false"<br />xmlDoc.load("accounts.xml")<br />for each x in xmlDoc.documentElement.childNodes<br />&amp;nbsp; &amp;nbsp;&amp;nbsp;document.write(x.nodename)<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; document.write(": ")<br />&amp;nbsp; &amp;nbsp;&amp;nbsp;document.write(x.text)<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; document.write(Request.QueryString("input"))<br />next</font>
  </p>
  <h2>
    <span>
      Detect applications that use the CDATA tag
    </span>
  </h2>
  <p>
    Look at both the application code and storage XML files to identify the usage of the <i>CDATA</i> tag.<span>&amp;nbsp;</span>Identifying <i>CDATA </i>tags inside XML documents is easy.<span>&amp;nbsp;</span>Just search the contents of all XML documents in your application looking for the string <i>CDATA</i>.<span>&amp;nbsp;</span>Then track down the code that uses the data read from this kind of tag.<span>&amp;nbsp;</span>Any component that directly writes the contents of <i>CDATA </i>tags to an HTML response is vulnerable to cross-site scripting attacks through XML injection.</p>
  <h2>
    <span>
      Don’t rely on XML Document Type Definitions (DTDs)
    </span>
  </h2>
  <p>
    <span>Programmers might assume that defining XML tags using DTD&amp;nbsp;protects them against XML injection attacks.&amp;nbsp;As we will see later on, this is a misconception.<span>&amp;nbsp;</span>Include any document that handles XML (using DTD or not) as a high risk component.</span>&amp;nbsp;</p>
  <h2>
    <span>
      Match High Risk Components with Entry Points
    </span>
  </h2>
  <p>
    <span>Non-validated XML data can come from any application entry point.<span>&amp;nbsp;</span>Make sure to cover all the possible sources of malicious data which might get passed to a client.<span>&amp;nbsp;</span>Common data sources include:</span>
  </p>
  <ul>
    <li>
      <span>Web forms</span>
    </li>
    <li>
      <span>URL contents</span>
    </li>
    <li>
      <span>Flash parameters</span>
    </li>
    <li>
      <span>XML store contents</span>
    </li>
    <li>
      <span>Web service data</span>
    </li>
    <li>
      <span>Graphical User Interface</span>&amp;nbsp;</li>
  </ul>
  <p>
    <span>List the high risk application components (usually web pages such as the ones in the scenarios above) and their related entry points to systematically aid with your testing:</span>
  </p>
  <p>
  </p>
  <table>
    <tbody>
      <tr>
        <td>
          <p>
            <b>
              <span>Component</span>
            </b>
          </p>
        </td>
        <td>
          <p>
            <b>
              <span>Line</span>
            </b>
          </p>
        </td>
        <td>
          <p>
            <b>
              <span>URL</span>
              <span>
              </span>
            </b>
          </p>
        </td>
        <td>
          <p>
            <b>
              <span>Form</span>
              <span>
              </span>
            </b>
          </p>
        </td>
        <td>
          <p>
            <b>
              <span>Flash</span>
              <span>
              </span>
            </b>
          </p>
        </td>
        <td>
          <p>
            <b>
              <span>DB</span>
              <span>
              </span>
            </b>
          </p>
        </td>
        <td>
          <p>
            <span>
              <b>Service</b>
            </span>
            <span>
            </span>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <p>
            <span>CreateChecking.php</span>
          </p>
        </td>
        <td>
          <p>
            <span>101</span>
          </p>
        </td>
        <td>
          <p>
            <span>X</span>
          </p>
        </td>
        <td>
          <p>
            <span>X</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>112</span>
          </p>
        </td>
        <td>
          <p>
            <span>X</span>
          </p>
        </td>
        <td>
          <p>
            <span>X</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>165</span>
          </p>
        </td>
        <td>
          <p>
            <span>X</span>
          </p>
        </td>
        <td>
          <p>
            <span>X</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <p>
            <span>Response.php</span>
          </p>
        </td>
        <td>
          <p>
            <span>1001</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>X</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>1116</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>X</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <p>
            <span>Present.php</span>
          </p>
        </td>
        <td>
          <p>
            <span>234</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>X</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>531</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>X</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <p>
            <span>showAccount.php</span>
          </p>
        </td>
        <td>
          <p>
            <span>432</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>&amp;nbsp;</span>
          </p>
        </td>
        <td>
          <p>
            <span>X</span>
          </p>
        </td>
      </tr>
    </tbody>
  </table>
  <h1>
    <span>Step 3:<span>&amp;nbsp; </span>Start Testing and Exploring<span>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; </span></span>
  </h1>
  <p>
    This step of testing is focused on submitting basic XML injection fuzz strings and observing how the application reacts.&amp;nbsp;Then, we will try to execute two simple XML injection attacks as shown in the previous scenarios:&amp;nbsp;tag injection and <i>CDATA</i> XSS.<span>&amp;nbsp;</span>Try all of the tests in this step through the easiest entry point for each high risk component.&amp;nbsp;In step 4 you will tune your test case data to cover the different formats and encoding depending on the remaining entry points.&amp;nbsp;</p>
  <h2>
    <span>
      Start with simple fuzz strings
    </span>
  </h2>
  <p>
    <span>Successful XML injection testing depends on whether the tester is able to send XML data that will end up being processed as expected XML.&amp;nbsp;</span>It is recommend that you start testing with a simple XML string consisting of a single quote, a closing tag character, an opening tag character and a double quote.&amp;nbsp;Try these four characters separately and combined:</p>
  <p>
    <font face="'Courier New'">'<br />"<br />&gt;<br />&lt;</font>
  </p>
  <p>or&amp;nbsp;</p>
  <p>
    <font face="'Courier New'">
      <span>'</span>
      <span>"&gt;&lt;<br /></span>
      <span>
        <span>&gt;</span>
      </span>
      <span>'</span>
      <span>"&lt;<br /></span>
      <span>
        <span>&lt;&gt;</span>
      </span>
      <span>'</span>
      <span>"</span>
    </font>
  </p>
  <p>
    <span>Then, observe how the XML-based server responds.<span>&amp;nbsp;</span>The idea is to modify a valid XML tag such as the first string below, to the second one.&amp;nbsp;</span>An invalid XML message from the server is a good indication that there are potential XML injection vulnerabilities present in the server application.</p>
  <p>
    <span>Another way to generate invalid XML is to add the start of an XML comment:</span>
    <span>&amp;nbsp;</span>
  </p>
  <p>
    <span>
      <font face="'Courier New'">xyz&lt;!--</font>
    </span>
    <span>
    </span>
  </p>
  <p>
    <span>Let’s say that you entered the string above as the username.<span>&amp;nbsp;</span>The resulting XML will now look like this and will end up being invalid:</span>
  </p>
  <p>
    <font face="'Courier New'">&lt;user&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;&lt;username&gt;xyz&lt;!--&lt;/username&gt;<br />&amp;nbsp; &amp;nbsp;&lt;password&gt;qwerty&lt;/password&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;&lt;userid&gt;111&lt;userid/&gt;<br />&amp;nbsp; &amp;nbsp;&lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;<br />&lt;/user&gt;</font>
  </p>
  <p>XML uses the ampersand character to refer to another entity in its user-defined XML schema.&amp;nbsp;For example, if the user passes the following string as the username, it will result in the corresponding XML:</p>
  <p>
    <font face="'Courier New'">&amp;xyz</font>
  </p>
  <p>
    <span>Results in:</span>
  </p>
  <p>
    <font face="'Courier New'">&lt;user&gt;<br />&amp;nbsp; &amp;nbsp;&lt;username&gt;&amp;xyz&lt;/username&gt;<br />&amp;nbsp; &amp;nbsp;&lt;password&gt;qwerty&lt;/password&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;&lt;userid&gt;111&lt;userid/&gt;<br />&amp;nbsp; &amp;nbsp;&lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;<br />&lt;/user&gt;</font>
  </p>
  <p>
    <span>This will attempt to refer to the </span>
    <span>&amp;xyz</span>
    <span> entity of the XML document.<span>&amp;nbsp;</span>If the document doesn’t contain this entity, then the newly built tag above will result in an invalid XML document.</span>&amp;nbsp;</p>
  <h2>
    <span>
      Learn from error messages to conduct a real attack
    </span>
  </h2>
  <p>
    <span>The purpose of creating invalid XML documents is so that you can start gaining information about the underlying XML format based on error messages they generate.<span>&amp;nbsp;</span>Let’s say you inserted the following fuzz string (<span>‘</span>) in an input field and the server responded with the following error message:</span>
  </p>
  <p>
    <font face="'Courier New'">Invalid XML:<br />&lt;user name='''/&gt;<br />&amp;nbsp; &amp;nbsp;&lt;id ='1232'/&gt;<br />&amp;nbsp; &amp;nbsp;&lt;realname='tester'&gt;<br />&amp;nbsp; &amp;nbsp;&lt;password='ind3$truct'/&gt;<br />&lt;user&gt;</font>
  </p>
  <p>Now, consider how you can utilize this information to create an additional, valid user while conserving the structure and format of the original XML document:</p>
  <p>
    <font face="'Courier New'">attacker'&gt;&lt;id ='1234'/&gt;&lt;realname='hacker'&gt;&lt;password='qwerty'/&gt;&lt;/user&gt;&lt;user name ='real_user&amp;nbsp;</font>
  </p>
  <p>
    <span>results in the server creating an extra element:</span>
  </p>
  <p>
    <font face="'Courier New'">&lt;user name='attacker'/&gt;<br />&amp;nbsp; &amp;nbsp;&lt;id ='1234'/&gt;<br />&amp;nbsp; &amp;nbsp;&lt;realname='hacker'&gt;<br />&amp;nbsp; &amp;nbsp;&lt;password='ind3$truct'/&gt;<br />&lt;/user&gt;<br />&lt;user name='real_user'/&gt;<br />&amp;nbsp; &amp;nbsp;&lt;id ='1232'/&gt;<br />&amp;nbsp; &amp;nbsp;&lt;realname='tester'&gt;<br />&amp;nbsp; &amp;nbsp;&lt;password='realuserpassword'/&gt;<br />&lt;/user&gt;</font>
  </p>
  <p>
    <span>
    </span>
  </p>
  <h2>
    <span>
      Try to exploit CDATA tags with Cross-Site Scripting (XSS) attacks
    </span>
  </h2>
  <p>
    To finish this step try to exploit the contents of CDATA tags to see if you can execute an XSS attack.&amp;nbsp;This test is quite straight forward, simply remember that the XML parser extracts all data enclosed in between the tags <i>&lt;![CDATA[</i>&amp;nbsp;and <i>]]&gt;</i>&amp;nbsp;to form a new string.<span>&amp;nbsp;</span>For example:</p>
  <p>
    <font face="'Courier New'">&lt;![CDATA[xyz]]&gt;</font>
  </p>
  <p>
    <span>Becomes:</span>
  </p>
  <p>
    <font face="'Courier New'">xyz</font>
  </p>
  <p>
    <span>In the same manner:</span>
  </p>
  <p>
    <font face="'Courier New'">&lt;![CDATA[&lt;]]&gt;script&lt;![CDATA[&gt;]]&gt;</font>
  </p>
  <p>Becomes:</p>
  <p>
    <font face="'Courier New'">&lt;script&gt;</font>
  </p>
  <p>
    <span>Finally</span>
    <span>:</span>
  </p>
  <p>
    <font face="'Courier New'">&lt;![CDATA[&lt;script&gt;alert('XSS')&lt;/script&gt;]]&gt;</font>
  </p>
  <p>
    <span>Becomes:</span>
  </p>
  <p>
    <font face="'Courier New'">&lt;script&gt;alert('XSS')&lt;/script&gt;</font>
  </p>
  <h1>
    <span>Step 4:<span>&amp;nbsp;</span>Tune Test Cases</span>
    <span>
    </span>
  </h1>
  <p>
    <span>During this step you must focus in modifying your test case data to cover all entry points based on the format of each specific entry point.<span>&amp;nbsp;</span>In addition, you must tune your test case data in order to execute additional XML Injection payloads. </span>
    <span>
    </span>
  </p>
  <h2>
    <span>
      Consider string format and encoding according to entry point
    </span>
  </h2>
  <h3>
    <span>Web Forms</span>
  </h3>
  <p>
    <span>
    </span>
    <span>Web forms are the easiest to test since they commonly allow most ASCII strings.<span>&amp;nbsp;</span>An attacker can try entering this string into an input field, for instance in the web form below:</span>
  </p>
  <p>
    <span>
    </span>
    <span>An attacker might try to enter this string in the email text field to execute an XML injection attack:</span>
  </p>
  <p>
    <font face="'Courier New'">JohnyC@examplesite.com&lt;/mail&gt;&lt;account type="savings"&gt;&lt;created&gt;03-02-2008&lt;/created&gt;&lt;number&gt;12345678&lt;/number&gt;&lt;balance&gt;1000000&lt;/balance&gt;&lt;/account&gt;</font>
  </p>
  <p>
    <span>It’s possible that client side checks are in place to match the contents of this text field with a valid email format.<span>&amp;nbsp;</span>However, client side checks are easily bypassed by removing them at the attacker’s end.</span>&amp;nbsp;</p>
  <h3>
    <span>URL Contents</span>
  </h3>
  <p>
    <span>The format of URLs tends to be more complex than that of other input fields.<span>&amp;nbsp;</span>This is due to the need for URLs to contain special or reserved characters, such as spaces, questions marks, single quotes, less than/greater than (&lt;/&gt;) symbols, and ampersands as data, rather than URL directives.<span>&amp;nbsp;</span>The client encodes the URL and then sends it to the server, which decodes it so that the special characters can be processed as data.</span>
  </p>
  <p>
    <span>How the encoding and decoding is done depends on the programming language in use.<span>&amp;nbsp;</span>For example, sometimes the encoding function replaces the blank spaces with a plus (+) sign, or the characters %20, so that:</span>
  </p>
  <p>
    <font face="'Courier New'">Joseph Cohen</font>
  </p>
  <p>
    <span>Becomes:</span>
  </p>
  <p>
    <font face="'Courier New'">Joseph+Cohen</font>
  </p>
  <p>or</p>
  <p>
    <font face="'Courier New'">Joseph%20Cohen</font>
  </p>
  <p>
    <span>The most common URL encoding scheme consists of replacing special and reserved characters with a percent sign and then their hexadecimal values (e.g. </span>
    <span>%HH</span>
    <span>).<span>&amp;nbsp;</span>Using this encoding scheme the URL seen below will be translated from:</span>
  </p>
  <p>
    <font face="'Courier New'">http://www.examplesite.com/CreateChecking.php?username=JohnyC&amp;password=qwerty&amp;email=JohnyC@examplesite.com&lt;/mail&gt;&lt;account type="savings"&gt;&lt;created&gt;03-02-2008&lt;/created&gt;&lt;number&gt;12345678&lt;/number&gt;&lt;balance&gt;1000000&lt;/balance&gt;&lt;/account&gt;</font>
  </p>
  <p>to:&amp;nbsp;</p>
  <p>
    <font face="'Courier New'">http://www.examplesite.com/CreateChecking.php?username=JohnyC&amp;password=qwerty&amp;email=JohnyC%40examplesite.com%3c%2fmail%3e%3caccount%20type%3d%22savings%22%3e%3ccreated%3e03-02-2008%3c%2fcreated%3e%3cnumber%3e12345678%3c %2fnumber%3e%3cbalance%3e1000000%3c%2fbalance%3e%3c%2faccount%3e</font>
  </p>
  <p>
    <span>This is because the below characters translate to their hex encoding like this:</span>&amp;nbsp;</p>
  <div>
    <table>
      <tbody>
        <tr>
          <td>
            <p>
              <span>space</span>
              <span>
              </span>
            </p>
          </td>
          <td>
            <p>
              <span>@</span>
              <span>
              </span>
            </p>
          </td>
          <td>
            <p>
              <span>&lt;</span>
              <span>&amp;nbsp;</span>
            </p>
          </td>
          <td>
            <p>
              <span>/</span>
              <span>
              </span>
            </p>
          </td>
          <td>
            <p>
              <span>&gt;</span>
              <span>&amp;nbsp;</span>
            </p>
          </td>
          <td>
            <p>
              <span>=</span>
              <span>
              </span>
            </p>
          </td>
          <td>
            <p>
              <span>"</span>
              <span>
              </span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              <span>%20</span>
            </p>
          </td>
          <td>
            <p>
              <span>%40</span>
            </p>
          </td>
          <td>
            <p>
              <span>%3c</span>
            </p>
          </td>
          <td>
            <p>
              <span>%2f</span>
            </p>
          </td>
          <td>
            <p>
              <span>%3e</span>
            </p>
          </td>
          <td>
            <p>
              <span>%3d</span>
            </p>
          </td>
          <td>
            <p>
              <span>%22</span>
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <h3>
    <span>Flash Parameters</span>
  </h3>
  <p>
    <span>Flash uses the </span>
    <span>
      <i>FlashVars </i>
    </span>
    <span>parameter tag from HTML embedded objects to collect user input:</span>
  </p>
  <p>
    <font face="'Courier New'">&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"<br />&amp;nbsp; &amp;nbsp;&amp;nbsp; codebase="http://macromedia.com/cabs/swflash.cab#version=6,0,0,0"<br />&amp;nbsp; &amp;nbsp;&amp;nbsp; width="250" height="250" id="flaMovie1" align="center"&gt;<br />&amp;nbsp; &amp;nbsp;&amp;nbsp; &lt;param name=movie value="flaMovie1.swf"&gt;<br />&amp;nbsp; &amp;nbsp;&amp;nbsp; &lt;param name=FlashVars value="input=userInput"&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;param name=quality value=high&gt;&amp;nbsp;<br />&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/object&gt;</font>
  </p>
  <p>
    <span>When testing through </span>
    <span>
      <i>FlashVars </i>
    </span>
    <span>you need to replace the </span>
    <span>userInput </span>
    <span>value with the XML injection string.&amp;nbsp;</span>Make sure that you also try different encodings when you test through this entry point.&amp;nbsp;</p>
  <h3>
    <span>XML store contents</span>
  </h3>
  <p>
    <span>
    </span>
  </p>
  <p>
    You must also tune your test case data when modifying the <i>CDATA </i>tag within XML files to execute a successful XSS attack.<span>&amp;nbsp;</span>For instance, some applications may blacklist any input that contains the following string, thus not allowing it to be placed in the XML data store:</p>
  <p>
    <font face="'Courier New'">&lt;script&gt;</font>&amp;nbsp;</p>
  <p>
    <span>
    </span>
  </p>
  <p>
    Here you may need to tweak your attack data to hide the script tags by adding extra <i>CDATA </i>tags
    
      
        :&amp;nbsp;
      
    
    
      
        &amp;nbsp;</p>
  <p>
    <font face="'Courier New'">&lt;data&gt;&lt;[CDATA[&lt;sc]]&gt;&lt;![CDATA[ript&gt;alert('XSS')&lt;/sc]]&gt;&lt;![CDATA[ript&gt;]]&gt;&lt;/data&gt;</font>
  </p>
  <p>
    <span>
    </span>
  </p>
  <p>
    At the end the contents within the <i>CDATA </i>tags get concatenated to construct a valid <i>&lt;script&gt;</i> tag.<span>&amp;nbsp;</span>This will bypass any checks done for <i>&lt;script&gt;</i> before the final concatenation.&amp;nbsp;</p>
  <h3>
    <span>Additional entry points</span>
    <span>&amp;nbsp;</span>
  </h3>
  <p>
    <span>Each application will have different ways of processing input from users, files, services, and other software entities.<span>&amp;nbsp;</span>Ensure that you understand the format of each entry point and cover the different formats on each entry point for each high risk component.</span>&amp;nbsp;</p>
  <h2>
    <span>Try additional payloads</span>
  </h2>
  <p>
    <span>So far you’ve learned how to execute two payloads:</span>
  </p>
  <ul>
    <li>
      <span>Tag injection.</span>
    </li>
    <li>
      <span>Cross-site scripting through CDATA tags.</span>
    </li>
  </ul>
  <p>
    <span>There are other payloads that you can try such as:</span>
  </p>
  <ul>
    <li>
      <span>Denial of service by consuming extra memory with excessive tags.</span>
    </li>
    <li>
      <span>Denial of service by resource exhaustion via recursive elements.</span>
    </li>
    <li>
      <span>Information disclosure attacks using XML External Entities (XEE)</span>
    </li>
  </ul>
  <p>
    <span>Each payload will require special tweaking of the XML attack data and might add new entry points to the scenario.<span>&amp;nbsp;</span>However, it is imperative that you keep up to date with the latest attack techniques related to XML injection and include them in your security test suite.</span>&amp;nbsp;</p>
  <h1>
    <span>Conclusions</span>
    <span>
    </span>
  </h1>
  <p>
    <span>Testing for XML injection requires that you understand how the application under test uses XML.<span>&amp;nbsp;</span>There are different scenarios ranging from when systems take XML as input, to when systems respond with XML as HTML output.<span>&amp;nbsp;</span>To successfully test for XML injection you need to understand these different scenarios.<span>&amp;nbsp;</span>Then, familiarize yourself with any potentially dangerous code and characteristics of any high risk components that are present.<span>&amp;nbsp;</span>Create a test plan that matches high risk components with their different entry points.<span>&amp;nbsp;</span>Then, start testing with simple test strings and observe how the application responds.<span>&amp;nbsp;</span>Finally, to achieve the most complete coverage, ensure that you tune your attack data to cover all formats in all entry points, and try different, up to date payloads.</span>
  </p>
  <p />]]></Data>
  </Content>
</TeamMentor_Article>