<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="0" Content_Hash="0">
  <Metadata>
    <Id>00000000-0000-0000-0000-0000000764e2</Id>
    <Library_Id>386553fa-9f33-4b11-b0bc-eb64b8d787ce</Library_Id>
    <Title>How to Test for Cross Site Scripting Vulnerabilities</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Implementation</Phase>
    <Technology> Any</Technology>
    <Type>Test</Type>
    <DirectLink>How to Test for Cross Site Scripting Vulnerabilities</DirectLink>
    <Author />
    <Priority />
    <Status />
  </Metadata>
  <Content Sanitized="false" DataType="html">
    <Data><![CDATA[<h1>Applies To</h1>
  <p>
  </p>
  <ul>
    <li>Applications that manipulate HTML input and output</li>
  </ul>
  <p />
  <h1>Summary</h1>
  <p>Cross site scripting (or XSS) is a well known HTML-related security vulnerability that commonly affects Internet clients through XSS vulnerable servers. A XSS bug in a web server allows an attacker to send malicious payload to a victim browser through the vulnerable server. Payloads may also execute in other HTTP clients not necessarily focused at browsing the web as long as they render HTML and execute any execute scripts. </p>
  <p>Below is a summary of steps needed for testing for XSS bugs</p>
  <ul>
    <li>
      Step 1: Understand XSS attack scenarios 
</li>
    <li>
      Step 2: List high risk componentsandentry points 
</li>
    <li>
      Step 3: Start testing and exploring 
</li>
    <li>
      Step 4: Tune test case data</li>
  </ul>
  <h1>
    <b>Step1: Understand XSS Attack Scenarios</b>
  </h1>
  <p>There are two types of XSS: reflective and persistent. A reflective XSS bug occurs when the web server takes input from a visitor and automatically sends him back the input without checking if the data inputted contains a script. Thus, the input data is reflected to the visitor and executes at the visitor's browser.&amp;nbsp;</p>
  <p>A persistent XSS bug is when a script embedded in malicious data is stored in a persistent store such as database, a file, or other storing mechanism. The malicious data containing a script persists in the server. If the server application takes this stored content and sends it to the client without validating its contents, the script will be executed in the browser.&amp;nbsp;</p>
  <p>It is important to understand both XSS attack scenarios to know what to look at when testing.</p>
  <h1>
    <b>Step 2: List High Risk Components and Entry Points</b>
  </h1>
  <h2>Identify high risk components</h2>
  <p>The next step in testing for XSS bugs is to do an extensive and careful revision of components that take input data from Internet clients and use send it back to the client. In case of large web services, documentation such as design or architectural, if available, become real handy at this point. Testers need to think about what components reflect data to a web client (for reflective XSS) and store data which is later send to a web client (for persistent XSS). Common components that do this include:&amp;nbsp;</p>
  <p>
  </p>
  <ul>
    <li>Search web pages</li>
    <li>Profile-related web pages</li>
    <li>Web forums</li>
    <li>Blogs</li>
    <li>RSS feeds</li>
    <li>HTML-based help browsers for thick clients&amp;nbsp;</li>
  </ul>
  <p />
  <h2>Look for code that writes HTML responses</h2>
  <p>There are many different scripting functions that append HTML to the server response. Finding the server-side code that writes data out is the first step evaluating and finding potential XSS issues. Functions to write data to a response vary depending on the language and platform you're testing. Be certain that you understand all the relevant functions in the language you're using.</p>
  <h2>Check for non-validated and unencoded data in responses</h2>
  <p>Next, check what is being output by the mechanisms above.&amp;nbsp;Even if the data written out by an application comes directly from the user and has not been specifically validated for format, if it is appropriately encoded, it can still be safe.&amp;nbsp; That said, the encoding must take the form of a whitelist of known-safe characters (generally only the alphanumerics), not a blacklist as is commonly attempted.</p>
  <h2>Match high risk components with entry points</h2>
  <p>Non-validated data comes from all of the application's entry points, not just the web. Be certain to cover all the possible sources of malicious data which might get passed to a client. Common data sources include:</p>
  <ul>
    <li>Web forms 
</li>
    <li>URL contents 
</li>
    <li>Cookie contents 
</li>
    <li>Flash parameters 
</li>
    <li>SQL database query contents 
</li>
    <li>Web service data 
</li>
    <li>Graphical User Interface</li>
  </ul>
  <p>List the high risk variables in the application and their data sources to make sure that they are covered during review and testing.<img src="about:../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image007.png" /></p>
  <h1>
    <b>Step 3: Start Test and Exploring&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; </b>
  </h1>
  <p>During this step testing is focused at submitting basic XSS fuzz strings and observing how the application reacts, and then trying to display a simple alert box that proves the existence of an XSS bug.</p>
  <h2>Start with a simple fuzz string</h2>
  <p>Success in finding XSS bugs depends on whether the tester is able to store or reflect an HTML script in or through the server. In almost all cases scripts are included in between <i>SCRIPT </i>tags (other tags also worked as explained later). During this step, it is recommended to start exploring how the server application's high risk components react to tag related input. A good idea is to start testing a simple fuzz string like this one:</p>
  <p>
    <font face="'Courier New'">'&gt;;!--"&gt;<xyz></xyz></font>
  </p>
  <p>Then look for the string <i>XYZ </i>in server's response to see how the server processed the special script related characters. It might turn out that the server uses the string inside of a tag:</p>
  <p>
    <font face="'Courier New'">
      <input maxlength="255" id="keyword" value="" type="text" name="keyword" />
      <a name="line163">
      </a>"'&gt;;!--"&gt;<xyz><_3d_26_7b_28_29_7d_22_ style="height:10px; color:#000;"></_3d_26_7b_28_29_7d_22_></xyz></font>
  </p>
  <p>Continue by modifying the initial string to try displaying an alert. The double quotes of the original fuzz string closed the <i>value</i> property so whatever came before doesn't matter. Also, after the closing parenthesis next to the letter <i>Z</i> the string can be anything. Taking the string can be simplified to this:</p>
  <p>
    <font face="'Courier New'">"&gt;<xyz></xyz></font>
  </p>
  <p>The server might reply with:</p>
  <p>
    <font face="'Courier New'">
      <input maxlength="255" id="keyword" value="" type="text" name="keyword" />
      <a name="line1631">
      </a>""&gt;<xyz>" style="height:10px; color:#000;" /&gt;</xyz></font>
  </p>
  <h2>Try to display an alert box</h2>]]></Data>
  </Content>
</TeamMentor_Article>